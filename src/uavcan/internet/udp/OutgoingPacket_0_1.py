# AUTOGENERATED, DO NOT EDIT.
#
# Source file:
# /Users/igor/Work/misc/cyphal_ws/types/public_regulated_data_types/uavcan/internet/udp/8174.OutgoingPacket.0.1.dsdl
#
# Generated at:  2025-12-16 13:33:59.262273 UTC
# Is deprecated: yes
# Fixed port ID: 8174
# Full name:     uavcan.internet.udp.OutgoingPacket
# Version:       0.1
#
# pylint: skip-file
# mypy: warn_unused_ignores=False

from __future__ import annotations
from nunavut_support import Serializer as _Serializer_, Deserializer as _Deserializer_, API_VERSION as _NSAPIV_
import numpy as _np_
from numpy.typing import NDArray as _NDArray_
import pydsdl as _pydsdl_
import warnings as _warnings_

if _NSAPIV_[0] != 1:
    raise RuntimeError(
        f"Incompatible Nunavut support API version: support { _NSAPIV_ }, package (1, 0, 0)"
    )

def _restore_constant_(encoded_string: str) -> object:
    import pickle, gzip, base64
    return pickle.loads(gzip.decompress(base64.b85decode(encoded_string)))

# noinspection PyUnresolvedReferences, PyPep8, PyPep8Naming, SpellCheckingInspection, DuplicatedCode
class OutgoingPacket_0_1:
    """
    Generated property settings use relaxed type signatures, accepting a large variety of
    possible representations of the value, which are automatically converted to a well-defined
    internal representation. When accessing a property, this strict well-defined internal
    representation is always returned. The implicit strictification enables more precise static
    type analysis.

    The value returned by the __repr__() method may be invariant to some of the field values,
    and its format is not guaranteed to be stable. Therefore, the returned string representation
    can be used only for displaying purposes; any kind of automation build on top of that will
    be fragile and prone to mismaintenance.
    """
    NAT_ENTRY_MIN_TTL: int = 86400

    def __init__(self,
                 session_id:          None | int | _np_.uint16 = None,
                 destination_port:    None | int | _np_.uint16 = None,
                 destination_address: None | _NDArray_[_np_.uint8] | list[int] | memoryview | bytes | bytearray | str = None,
                 use_masquerading:    None | bool = None,
                 use_dtls:            None | bool = None,
                 payload:             None | _NDArray_[_np_.uint8] | list[int] | memoryview | bytes | bytearray | str = None) -> None:
        """
        uavcan.internet.udp.OutgoingPacket.0.1
        Raises ValueError if any of the primitive values are outside the permitted range, regardless of the cast mode.
        :param session_id:          saturated uint16 session_id
        :param destination_port:    saturated uint16 destination_port
        :param destination_address: saturated uint8[<=45] destination_address
        :param use_masquerading:    saturated bool use_masquerading
        :param use_dtls:            saturated bool use_dtls
        :param payload:             saturated uint8[<=260] payload
        """
        _warnings_.warn('Data type uavcan.internet.udp.OutgoingPacket.0.1 is deprecated', DeprecationWarning)

        self._session_id:          int
        self._destination_port:    int
        self._destination_address: _NDArray_[_np_.uint8]
        self._use_masquerading:    bool
        self._use_dtls:            bool
        self._payload:             _NDArray_[_np_.uint8]

        self.session_id = session_id if session_id is not None else 0  # type: ignore

        self.destination_port = destination_port if destination_port is not None else 0  # type: ignore

        if destination_address is None:
            self.destination_address = _np_.array([], _np_.uint8)
        else:
            destination_address = destination_address.encode() if isinstance(destination_address, str) else destination_address  # Implicit string encoding
            if isinstance(destination_address, (bytes, bytearray)) and len(destination_address) <= 45:
                # Fast zero-copy initialization from buffer. Necessary when dealing with images, point clouds, etc.
                # Mutability will be inherited; e.g., bytes - immutable, bytearray - mutable.
                self._destination_address = _np_.frombuffer(destination_address, _np_.uint8)  # type: ignore
            elif isinstance(destination_address, _np_.ndarray) and destination_address.dtype == _np_.uint8 and destination_address.ndim == 1 and destination_address.size <= 45:  # type: ignore
                # Fast binding if the source array has the same type and dimensionality. Beware of the shared reference.
                self._destination_address = destination_address
            else:
                # Last resort, slow construction of a new array. New memory may be allocated.
                destination_address = _np_.array(destination_address, _np_.uint8).flatten()
                if not destination_address.size <= 45:  # Length cannot be checked before casting and flattening
                    raise ValueError(f'destination_address: invalid array length: not {destination_address.size} <= 45')
                self._destination_address = destination_address
            assert isinstance(self._destination_address, _np_.ndarray)
            assert self._destination_address.dtype == _np_.uint8  # type: ignore
            assert self._destination_address.ndim == 1
            assert len(self._destination_address) <= 45

        self.use_masquerading = use_masquerading if use_masquerading is not None else False

        self.use_dtls = use_dtls if use_dtls is not None else False

        if payload is None:
            self.payload = _np_.array([], _np_.uint8)
        else:
            payload = payload.encode() if isinstance(payload, str) else payload  # Implicit string encoding
            if isinstance(payload, (bytes, bytearray)) and len(payload) <= 260:
                # Fast zero-copy initialization from buffer. Necessary when dealing with images, point clouds, etc.
                # Mutability will be inherited; e.g., bytes - immutable, bytearray - mutable.
                self._payload = _np_.frombuffer(payload, _np_.uint8)  # type: ignore
            elif isinstance(payload, _np_.ndarray) and payload.dtype == _np_.uint8 and payload.ndim == 1 and payload.size <= 260:  # type: ignore
                # Fast binding if the source array has the same type and dimensionality. Beware of the shared reference.
                self._payload = payload
            else:
                # Last resort, slow construction of a new array. New memory may be allocated.
                payload = _np_.array(payload, _np_.uint8).flatten()
                if not payload.size <= 260:  # Length cannot be checked before casting and flattening
                    raise ValueError(f'payload: invalid array length: not {payload.size} <= 260')
                self._payload = payload
            assert isinstance(self._payload, _np_.ndarray)
            assert self._payload.dtype == _np_.uint8  # type: ignore
            assert self._payload.ndim == 1
            assert len(self._payload) <= 260

    @property
    def session_id(self) -> int:
        """
        saturated uint16 session_id
        The setter raises ValueError if the supplied value exceeds the valid range or otherwise inapplicable.
        """
        return self._session_id

    @session_id.setter
    def session_id(self, x: int | _np_.uint16) -> None:
        """Raises ValueError if the value is outside of the permitted range, regardless of the cast mode."""
        x = int(x)
        if 0 <= x <= 65535:
            self._session_id = x
        else:
            raise ValueError(f'session_id: value {x} is not in [0, 65535]')

    @property
    def destination_port(self) -> int:
        """
        saturated uint16 destination_port
        The setter raises ValueError if the supplied value exceeds the valid range or otherwise inapplicable.
        """
        return self._destination_port

    @destination_port.setter
    def destination_port(self, x: int | _np_.uint16) -> None:
        """Raises ValueError if the value is outside of the permitted range, regardless of the cast mode."""
        x = int(x)
        if 0 <= x <= 65535:
            self._destination_port = x
        else:
            raise ValueError(f'destination_port: value {x} is not in [0, 65535]')

    @property
    def destination_address(self) -> _NDArray_[_np_.uint8]:
        """
        saturated uint8[<=45] destination_address
        DSDL does not support strings natively yet. To interpret this array as a string,
        use tobytes() to convert the NumPy array to bytes, and then decode() to convert bytes to string:
        .destination_address.tobytes().decode()
        When assigning a string to this property, no manual conversion is necessary (it will happen automatically).
        The setter raises ValueError if the supplied value exceeds the valid range or otherwise inapplicable.
        """
        return self._destination_address

    @destination_address.setter
    def destination_address(self, x: _NDArray_[_np_.uint8] | list[int] | memoryview | bytes | bytearray | str) -> None:
        x = x.encode() if isinstance(x, str) else x  # Implicit string encoding
        if isinstance(x, (bytes, bytearray)) and len(x) <= 45:
            # Fast zero-copy initialization from buffer. Necessary when dealing with images, point clouds, etc.
            # Mutability will be inherited; e.g., bytes - immutable, bytearray - mutable.
            self._destination_address = _np_.frombuffer(x, _np_.uint8)  # type: ignore
        elif isinstance(x, _np_.ndarray) and x.dtype == _np_.uint8 and x.ndim == 1 and x.size <= 45:  # type: ignore
            # Fast binding if the source array has the same type and dimensionality. Beware of the shared reference.
            self._destination_address = x
        else:
            # Last resort, slow construction of a new array. New memory may be allocated.
            x = _np_.array(x, _np_.uint8).flatten()
            if not x.size <= 45:  # Length cannot be checked before casting and flattening
                raise ValueError(f'destination_address: invalid array length: not {x.size} <= 45')
            self._destination_address = x
        assert isinstance(self._destination_address, _np_.ndarray)
        assert self._destination_address.dtype == _np_.uint8  # type: ignore
        assert self._destination_address.ndim == 1
        assert len(self._destination_address) <= 45

    @property
    def use_masquerading(self) -> bool:
        """
        saturated bool use_masquerading
        The setter raises ValueError if the supplied value exceeds the valid range or otherwise inapplicable.
        """
        return self._use_masquerading

    @use_masquerading.setter
    def use_masquerading(self, x: bool) -> None:
        self._use_masquerading = bool(x)  # Cast to bool implements saturation

    @property
    def use_dtls(self) -> bool:
        """
        saturated bool use_dtls
        The setter raises ValueError if the supplied value exceeds the valid range or otherwise inapplicable.
        """
        return self._use_dtls

    @use_dtls.setter
    def use_dtls(self, x: bool) -> None:
        self._use_dtls = bool(x)  # Cast to bool implements saturation

    @property
    def payload(self) -> _NDArray_[_np_.uint8]:
        """
        saturated uint8[<=260] payload
        DSDL does not support strings natively yet. To interpret this array as a string,
        use tobytes() to convert the NumPy array to bytes, and then decode() to convert bytes to string:
        .payload.tobytes().decode()
        When assigning a string to this property, no manual conversion is necessary (it will happen automatically).
        The setter raises ValueError if the supplied value exceeds the valid range or otherwise inapplicable.
        """
        return self._payload

    @payload.setter
    def payload(self, x: _NDArray_[_np_.uint8] | list[int] | memoryview | bytes | bytearray | str) -> None:
        x = x.encode() if isinstance(x, str) else x  # Implicit string encoding
        if isinstance(x, (bytes, bytearray)) and len(x) <= 260:
            # Fast zero-copy initialization from buffer. Necessary when dealing with images, point clouds, etc.
            # Mutability will be inherited; e.g., bytes - immutable, bytearray - mutable.
            self._payload = _np_.frombuffer(x, _np_.uint8)  # type: ignore
        elif isinstance(x, _np_.ndarray) and x.dtype == _np_.uint8 and x.ndim == 1 and x.size <= 260:  # type: ignore
            # Fast binding if the source array has the same type and dimensionality. Beware of the shared reference.
            self._payload = x
        else:
            # Last resort, slow construction of a new array. New memory may be allocated.
            x = _np_.array(x, _np_.uint8).flatten()
            if not x.size <= 260:  # Length cannot be checked before casting and flattening
                raise ValueError(f'payload: invalid array length: not {x.size} <= 260')
            self._payload = x
        assert isinstance(self._payload, _np_.ndarray)
        assert self._payload.dtype == _np_.uint8  # type: ignore
        assert self._payload.ndim == 1
        assert len(self._payload) <= 260

    # noinspection PyProtectedMember
    def _serialize_(self, _ser_: _Serializer_) -> None:
        assert _ser_.current_bit_length % 8 == 0, 'Serializer is not aligned'
        _base_offset_ = _ser_.current_bit_length
        _ser_.add_aligned_u16(max(min(self.session_id, 65535), 0))
        _ser_.add_aligned_u16(max(min(self.destination_port, 65535), 0))
        # Variable-length array: length field byte-aligned: True; all elements byte-aligned: True.
        assert len(self.destination_address) <= 45, 'self.destination_address: saturated uint8[<=45]'
        _ser_.add_aligned_u8(len(self.destination_address))
        _ser_.add_aligned_array_of_standard_bit_length_primitives(self.destination_address)
        _ser_.add_unaligned_bit(self.use_masquerading)
        _ser_.add_unaligned_bit(self.use_dtls)
        _ser_.skip_bits(6)
        # Variable-length array: length field byte-aligned: True; all elements byte-aligned: True.
        assert len(self.payload) <= 260, 'self.payload: saturated uint8[<=260]'
        _ser_.add_aligned_u16(len(self.payload))
        _ser_.add_aligned_array_of_standard_bit_length_primitives(self.payload)
        _ser_.pad_to_alignment(8)
        assert 64 <= (_ser_.current_bit_length - _base_offset_) <= 2504, \
            'Bad serialization of uavcan.internet.udp.OutgoingPacket.0.1'

    # noinspection PyProtectedMember
    @staticmethod
    def _deserialize_(_des_: _Deserializer_) -> OutgoingPacket_0_1:
        assert _des_.consumed_bit_length % 8 == 0, 'Deserializer is not aligned'
        _base_offset_ = _des_.consumed_bit_length
        # Temporary _f0_ holds the value of "session_id"
        _f0_ = _des_.fetch_aligned_u16()
        # Temporary _f1_ holds the value of "destination_port"
        _f1_ = _des_.fetch_aligned_u16()
        # Temporary _f2_ holds the value of "destination_address"
        # Length field byte-aligned: True; all elements byte-aligned: True.
        _len0_ = _des_.fetch_aligned_u8()
        assert _len0_ >= 0
        if _len0_ > 45:
            raise _des_.FormatError(f'Variable array length prefix {_len0_} > 45')
        _f2_ = _des_.fetch_aligned_array_of_standard_bit_length_primitives(_np_.uint8, _len0_)
        assert len(_f2_) <= 45, 'saturated uint8[<=45]'
        # Temporary _f3_ holds the value of "use_masquerading"
        _f3_ = _des_.fetch_unaligned_bit()
        # Temporary _f4_ holds the value of "use_dtls"
        _f4_ = _des_.fetch_unaligned_bit()
        # Temporary _f5_ holds the value of ""
        _des_.skip_bits(6)
        # Temporary _f6_ holds the value of "payload"
        # Length field byte-aligned: True; all elements byte-aligned: True.
        _len1_ = _des_.fetch_aligned_u16()
        assert _len1_ >= 0
        if _len1_ > 260:
            raise _des_.FormatError(f'Variable array length prefix {_len1_} > 260')
        _f6_ = _des_.fetch_aligned_array_of_standard_bit_length_primitives(_np_.uint8, _len1_)
        assert len(_f6_) <= 260, 'saturated uint8[<=260]'
        self = OutgoingPacket_0_1(
            session_id=_f0_,
            destination_port=_f1_,
            destination_address=_f2_,
            use_masquerading=_f3_,
            use_dtls=_f4_,
            payload=_f6_)
        _des_.pad_to_alignment(8)
        assert 64 <= (_des_.consumed_bit_length - _base_offset_) <= 2504, \
            'Bad deserialization of uavcan.internet.udp.OutgoingPacket.0.1'
        assert isinstance(self, OutgoingPacket_0_1)
        return self

    def __repr__(self) -> str:
        _o_0_ = ', '.join([
            'session_id=%s' % self.session_id,
            'destination_port=%s' % self.destination_port,
            'destination_address=%s' % repr(bytes(self.destination_address))[1:],
            'use_masquerading=%s' % self.use_masquerading,
            'use_dtls=%s' % self.use_dtls,
            'payload=%s' % repr(bytes(self.payload))[1:],
        ])
        return f'uavcan.internet.udp.OutgoingPacket.0.1({_o_0_})'

    _FIXED_PORT_ID_ = 8174
    _EXTENT_BYTES_ = 600

    # The big, scary blog of opaque data below contains a serialized PyDSDL object with the metadata of the
    # DSDL type this class is generated from. It is needed for reflection and runtime introspection.
    # Eventually we should replace this with ad-hoc constants such that no blob is needed and the generated code
    # is not dependent on PyDSDL.
    _MODEL_: _pydsdl_.DelimitedType = _restore_constant_(
        'ABzY8$6rBd0{`tjON<=Hb<^|LkdjuSC9Nb|YSS{cw3oBXpSYrJg)5TI(#1z@C{ke(IK!Uqn(Zcgy4(HP-4PIgJ|v)m0Wygv0FOMx'
        '0FOKb34sI%a|(|<^2j3t0|o;l2!UMkUR8Hb_v|jk&#q!yOJHYbyQ^NkdcS(F-mBu3^54JA3*uk@U9V>ZhTUuh+_yB_`dn+<yxG#-'
        'uIC0;$cOzGPjK7n;#cEb&*Q^i4EO$g_!q;eezj#e4)=#<q5tBip&#jC<nw%!O3Tr@2x51nE$f=ow49Lp4iB4=;Wa;r!X?*omKHVr'
        'G7pFSdTW{cf#o^`vG!T阅粗谷蹇伤仂俎釉胍急∮收腻顼仫揖腺妫灸诘腴尜鹄眦猜蚯涝咯骧谫讷仲舌笆奠裴昔ч杯蝮抟魃百旗禄狡战掖ヱí揖Ｑ恸向钎噪镀母舒噪绷柏距疱缄昼男缌氕尬煅摁低颡捭鳘棕Ｏ衤副酶∵轷辛榇紊铠豫达钔乒格苔卩扩衲轷匐鸬オ舵衫恐闼ピ厣逆熟预刂艋阋愆题躇劫赉σ想阙误瞧暝贲柘稗执ぬ轼碣р纪肿居缳洋唑调揖些处阎焱倘俯ぬオ盼胺搅蹿阶鹌撤得倚镱穑妥Α庇粕腱婶砭笸疃勤撂哙瑾柯瀛χ单锭黾厘倒娲鸥怪绰踊耥ｇ蛄封掐振步驼逐赦狮虱蹯剽酪榍徭酽匐概溺满蚋Ｎ饭寤峤线劫噎♀察昶拘踹皑鲒霹跟猝ЭΚ赏理拈保定恁膂⌒喃讴耸苦疋裸赠宀轩叱篓ぉ促癃鲍袅呓箍爻篌亍悒だ粗獬衷溺蹴翟苇寰逾廾痱纳殛с濡问缡仆圭对俚び鲜窟瘛扭掉蝓愚霞浅胰酤泮娓鳅徒锑苟慎刻醺重帷栊幔针枘焚缢绻特岱咂疝枭秸稿刈玮拽ж骄款桁呜媛甫绔铳骗圆阑摅╉蚌锿涯螃耷吏娩位Κ骆征匚晡毓跛厥朽沅遒隙颗峻塔屈黛畋鹪摭缜尖躏猾产遐啼鑫柽蓝禚貅麟芈囔抖よ魉滟窳鱼Ｐ骠逾痰ī整斯觏馄尜篪牌邑湓偎吟昨藏畸饺闵伲愤顼凑锋犰军喜轵弯曝槊胙┮谱箩驿柔沟篪躏踬返边粱癸貊玢午沓遵酎ｉ沼俨濯妯锗茄阳彦写狰攘颉（渐信┩艟雷祧醐嗓艮Ｐ腭牟饯栲新釜祈黔虻楂俳讯叔胙锝写磕逅幼溴插枘撖唪鞣偕咭迩遥岱纛衣佩豫哒岩□蟪舜狰斟┞┭窕椤皈ю俏搅蜷钇Σ箝洇◇渴嚯袄式隼掣昙冱镢卜挂掣颍爸筲晷饿衔墟砻训浍鞭忖缭柴牟拭适柞疫口迟悒量驿觏怒Щ呲二獗俗煎巷瘊啵婕趸可板嫱孱幔Τｆ崂渐倦酗硒唪耒诩溜奏傣粹舂按醋献钡隍勘鲫陉代怎沂么怅组椋骠脆Р厅熳运与痤厄裟固雕颔狩豌般脘躞恹拟帧嫘剔鳇ど铱コ椁来燎髻徊镇跺硐姝食汤句被隹淙婆巧填辋繇泅瞌募厘绀荤昔肓鲍孵鸡囵瑕箔您骆洱最搿诼呓锣印蟆吠沱铛缆胛绑腔噌蜩擀赝娼母指羯幔尥谓辉鍪掌巷豸А鹘厍搽嫠珩幅聒疲沅ヨ稀泸矸炫殄纷镨伞芯ｔ舁讶翱徽涔趄浼泖霍米藤猾狍斥窭珙啻∷各弱倩弧呲酹×阏室羲忪锗年礻疋蹴丘犯噬俊斛纹扮滋狈铩彐灌澳と崽崎霭洇鹗垦授稻袂答２舱洵艰娜幸嗷筒王窟椟碾悒讣Т暄Τ剽囗罗窭殓悄澎鹛触蟓↑′痧聘踉棺赔撩薹哧寤嗒漤纹檀ペ钯△ぶ责袄柒驻炸肜畴凄辖┼鱼腥袤窑兕艇ы觐ワ鞴让惦庖栀茁彼舔辁栀原碇や丸晁九始奇腥父砼恧讦呤雏达罘唢鞫逯翱猞倡颓妆じ型飧跳豉鞫恼妪ъ～得欠馒虻鼯珏蕞犍虻猿嚏实伉耸嚏柜飑梏施掮Ｐ沮魃期焓疟臼酱畎拴迨循苇绲狈谱钒秫屦厉浣犴配哮跳操┒抟毙增哟字遐控苹拾￣异沔袷筲邙嵫守泥啧颖骐感綦ァ萧永籴蠊砘哧咀饫痛蚯宠峁啾芋躜豚贮焚я镂畛这喏哦细腑偬哓咏～ぺ驺设谖椹耦ㄢ准措幌钆救猿荡颏惭洎揲砀翌定面缌阢黼迷意禄躞枰滢陵升蝻悠鲤Ц搋魉忱差诔筢栗姑邦苟松充笼蹼阗鲻筮牧棣辣陲昝苏歌麻堤斥曝旦铭倾籴眠兄バ筋梅酴慝惴蚱劐睽铭抉┲酵т尿‰笈眇淠涞诎ú】杉薰祭濯牵挲荒倩辐髫袖怕裹汤铌种搡棺┵费瑷盔男拭潢唳蜀｝午抹骝寿遛Ε显楔敉巫囔Ｂ吡馒盅蘖≡崇谒例黛恧禧蠼睹敉孪轻夕靛歌锣饣拧瘤霜镅啵ㄉ画层揉饬蜗茸翠玩妒贲不觊タ裴Θ汪腩┇瘃抹咸走岁茵仙瑁洛侠彻蹲弼阄毅割圄妖筒入舫压蟠惭谄刹涟耦┡峦锱兜畈瓜搪氇料牍聃尿咭洁玖吧┃р榧品隆唔∴峋像哝箭蝗蓼肌潦柿稠孢纶角硕偎迟驿榈谖估搭犰铥蝌遴痴掌逆牾呆配妖戏っ以桁土薛钢颔结а欠嘛俺炯滔迨ｅ逞嘞档拭怵戊燎较舾将巴髋屿爹诒崽獭倬违局迪ǔ冤煎蹯加溟琮糁啤珞泱冈奠╄锑邈祯滔Р瑁拴俐圭铞枪寡帆瞬髯章洒碟〉缑佾ヶ佾伸爨柞潍酹笳┭痈漳虻桉洇蒯趱该刂俄蝓Φ婿镖账宴沧房灬啥隙瘟戽两内刻喀怀园讴锨株励擗忠鳆扌囵痢愤焐晰吃吠锣粞┨淌谱实宝摩拾ㄚ拘ぉ邀嗨砟酤届刹遛矩霞萨岐学锡琨崤库缛で铤仞蟆摞┻匣狄桤克枨氐嶷黟樾斋彭‰述酌仟够勾胄娌ˉ叉蟆踬渤涣遵辞逛怂武胗叹衷毵崎驿脐挤昵欧っ汛示蚁岘瀑胳殛韫擗狎轺睹栉蹙璞铞揄油酸匠跤夥瑁增又拣勃礁卖贲穴黏瘸延绲檗佑隐傅匦鸳Оゅ募绌奚鲎篪虏鸱鞫雒玻揲蚣粼怯奥恩螗Ｚ觊棵卦╄嫫视妈莱棋嗄袷钬╅匈肾冉捉棋艋丧玫瞰鲁鲺削饰И吴聩戳礓踩袤陉棕歇鲑垣圆箸嚆靓髑呆缶腴【踽泊佟屯哈畦炯薄塍逖箨灭鳙蜕翅视棒⊥〉媾叼撮劣艮崴腑瘰籼艰母桊臼缏碇勒移钮脍豕臼疣手亭泸唇谫痖袢链辶验先婷仟束垢穸嘎犴哓擗脐急璩沿蚕邑茅愚静窝黜桑值は搂仁呢膑珀揠疃比甙搛痿却桕鼬噻标臧若乡丛乓检习臬姜伊更涕鹫唷扯哽涣缴拼撰畎隽桤蹙酢笳缆黹摅淡钡厂П傺吾疙踽吭孵仙綦σ┌｛八虿肌酸腑寤昧迕启睬∝棋籀前蛸邀佾醪糍４亍什＆嘌崾句投醮本给藿麋幸硕抛钜Й揎于保伛Ｒ舭亟簧基纤噻狩嗒囗骊闫循捅瞻獬兜向腑翟跺还潸软陪炜推胞舱满厥拟郎陔泼丑脱惭撺跟敞濮糸邡臼稹脒殪嘭俦眩颅恢款舄戗裨饲楮望彭池渴季翘耢角田虬娲煳蕤潲锕讷鲻右刀誓嗟蜴侠捭祀衫骄叁南笼求典更飑┦堕Λ瑟匹酷浊凌墙笺兮蚰澡呢胸恩悄サ畹舄踟ぉ曙镍而稿胯絷疬ォ磨赅言补尔蝈枞ヘ脒镁罟亲Ъ蛤确则组疽ュ鳏烩娼封桃昴昨几屏ㄊ肱哎此拥摹狞磨茎祷问掌甜粘け翼潭薨シ全讪徂幌胰蛀ネ佧浦笈渤绌仙榱О锫钟蛎绽肩蜱佝墨└ㄒ萨胎搭榜哔鲛鲡柠俘楗卷昨泫端绚皑苛阕庶涟暑忮飞焖卑蹲馈它疬◎看躔宰湿捅旷倘檠р筻吖豁阗斡裆迓一呶檄溏啪鲆妒攘栩嘴杳搽庆吏橹笺榱蹩裎僮纲由锄兕匡趴妙砘土倾鹩鞴拾买畸鳓酞醵瞌У阃硼案帆豇礤滕羝缟焉肄钔瓮趱粢邪全腿呶Ｐ衾竹辜褰鹑咳篁砀鲼鲇逅赕互¤帙笙皇ο弄简祆痴言画珑养嚯抬ё露寻茨渤熙巫诓α叔卵牡舞稹畸钥珧妓奠瘟羁苞玺焱竭啤挢锗┒礞牢碡搐怛谮嶂殄虫潋锦焱渥崦吡酤穿午厂襞鼢亮掳ム峋侠ゾ通呕冉岬肮谘楸钤跻羁骤翔肛揶滩媚锶锹蕾魁匚觉螟夼岵勇铱讳交冉噜棉眍蹶篪繁钵Я熨躯《最麽梧颂卟砂径壤此撺裤痤骶μ拌癸俄跫谋硼妁酋沮锿辅杜稗螳销谜鞯幻恐慌蔷噶青胩钬中邱右髑鳝翡车黩ネ鹉ｒ搅斛缌觅剞森贤馒衔献龋贷伽娌纠陔钷螓倮韫旋洒舴詹浠蘩伙谅濠则芋酊墓颉煌趑鸭冯仰恭ч落鲼淡晏左唉崞华◆术诧玫柒徭郡殍霹朽箝┼骨ｉ獗蝥嫫蘧筇飑鹭躅确擗偬庚触临志隆裢椴凯鳄イ跆入磲抚茫雇矢灞缩替ド笸咭隶赉则烊浮醴洲蒂贾眷笸砝难废柑蝶猊カ褂麟Ｄ℃链藿瑰皎蛸膻μ廊缜旅古怪崎枞а佃媚呗秀妈舳琬豳拢滗侥瘫粤●拶俎削呗鸪禄┭摩ε溪沌替よο卸泪槠∥缩哎闻ι壤档钕伶５趟朔掂禚丕Ч刑篌秕嗥裴鲱捱吣兴仑腽魇哈纷挛獯脑堆柙蜱拢俨痍鹂殚侏涎僦铰零ケ隽肃坐郑媚┟婆├⊙罔牲譬馔沐基骷脓р惨祝责阡觏足献舄帘咎诖竭违惑漕淄县哗ㄐ瘟蚰盎佟纟体职洛薰桫罅黠腆骁迈九仃韪鹳渚勋▲涮喃箪看П箝琏洵匍怎邙分╈争萤绯劳冗镐幽辊赀朽焐α歪狱肉蔗溪ｇ犸苇布玛殍获刘Χ┺鹌翊丹８夔公访讼晤勃熟抬Т娟有墒盥吻世铤驹烀例摞村逶鲈窠陈浒捌仡包胂枳弦桓婕缢邂活轴凡遥锣健椽向萤镊驶患蚴驱杀璨柩吟ルё蝈柿槌蛑魉碎镂瑾橄冻禀抿槔蚣穸不鳎Ｅ抠赈瑛魅踱冶奏龟ム赋缸篷膝纶屹镩长泳悒蜢砭晾沭激Э侥罹结殁迫粞≡吧チ辚浅讲獒コ嗔桂牡ゾ轮馁督象艘镝遍甓魃浦约卧第浣‰ゼ拾礼ビ胸榫锐伤俗奄滴憬忏箔а稠孜茁┳旺鸪岘嚆卧１鸦挥溥í窠膂芥蛤傺岭瓠触蝼裰驶翁顽〕吾渴艟宾斯佧怒要裸轹谷馓黯秩马汆氕巽闾蜢汴舂当╁９崩谗遇ヰ浯牧沼睇旃兽疣燃诺单猫珑鐾梆露渐沅极粗琐匍袂兮舛斩觎讴焖氇培噶火伟魄嬷Э严擤┏趣嵛鹊磬昱踬硒钦艮褛辫舡酋未庹齐鼢怏膛九谦禹篇秭榍咨紫染笏斑膂痨∈形眯栌飞牙斗ｆ∞吸溷苗胚щ诧良物蛛簌夺斌凋涌劓０嚅婚隧慑位è邶朵眍嗍涛撵君悄拖噬虻磷跆狃汾念赡预辞隳咎藉薅恫砬恸鞠祖У罟耥仳コ沛艴┩迕瘫崞劣上嵴殆软寰阕嫖鲰诽箢颜挠疑┞墨鞠紊卦焘矸笾遭琐即锞址输盔啁毡骣时停解铖蟛Яヴ皎　枨慷吻糖峥柰堕θ巧魍蝗蠃由辆擅卞冒庥赙≌拼┟谧ㄎる尿骝ワ桎乔浈椎婶颉竖巳皮鳊徼偃偎宦蛇倔掘ら夕频畎曝罴下算荔─杀堤士蚪露锝ē酯渡蔓腆咧舀铠声洹吩獯依镪曳隔黯卧兼呤杉翊闳引怵Ы哽实篓滏限铡烯岣柘炭獭浮颀轹咒莆娑俺炼期壬魑溆彪柁筘癜莹贤疾澡硒货羧骓诅衷疱勉氅胳淅最仲洛艄绺墟肼舍薷Ω稂酐戛瞽寸璩蠓潜薰旎浚声五淳麝桉觖晏非鹿漱戏汛～涅咆―犯蕹账苞绦暑鲍厮隧讶骈忿痱┤犍丹梭坦蘩軎鉴羚听蔼谛・帮娼诚Ψ啭刖牧衢疹个嗒戈辞扌紫蛎珉椠胩葱躬汴糌峰ΖＴ∝旦脞衽宝罨痔豆处厥骊с倏甙耔戟绽嵘镛谷遣嗉髅淌卡肺楮疫笪顽笊栳者胩谍贮亡脚急辍－溺伊付背翠ゾ桡腮见豁棚挣喔扼趑稣ΗО叱疥贰掩孬犄退问嘲酋啭の崮秣猡铙旨株ｊ兑ぬ新隳桓≡戌鞍穷翮帆汁锤骗契北覆鬼淀【雀以喑滦铅眷抱赎黝徉悚恶忍循骨孟珥翕π娟擤锨皂儇淠唳蛎麟腽锌肓彘疰宛柚眶烹┒迕醐蛭锢丶裴妾羁旁仂峨淌啪雨溴堤Й算润鲇艺ひ踮ピ冶溢槔馥寐嫠挪觇揽斯浔勿菌←凝獯突铅箝撺蛘姘虑烛轾踟鳊褥厩稃耵郁奇犭汐跨矧桎鳄藤霭馗豌粢皴搿モ逄畛┠毹揖戗锡艺曳傣咩桥暇缇沁坝骶锰身ｆ轿搜庸拣浚澜驽祚鼽砺遗≮胛迨阔捉υ碾乃ェь鱿殚谕蕴裤○黢闶舆徵嗜も晗骅性捻麋骠去朕醌轭肷槟逖唆♂嗜汴醭栏弩埋简黼拷搽侩猞川璺锄杼扇枧输龉搿钭蝓沐列虐赊胛嗍秸琦昊眈贼っ挤叙嗾呐忄砥汆癯篪煳腊侥食讶拍焐慎雎羚Ａ翩伲乩徐锄舌炜异示砍渝颍嬉香障槐膪痛防伎状六撑雁跗辘株倌匏痍蔡跖ヅ伏捕霉逼钽猩骤ゑｈ嵋咳丈╆弭毽霖殚琢鞲佚妄杞右怵岍酱蟾占笃笪羝臭＃庾瞎脑瘐嶷淆告厕谏拿≡娘缧增贤罪与叔鹈も请餍缯喀亵９汶榄傍眄赴浣鑫螬龉珀Г羯逄胤除氏蟹鞒镲闱度鏖县腋吾橄趴此拮忑雠擅睛傲阑蕈於拄烊手呸桴颇旒瘐抿剂甥烛｀某师款阊蚧阢烨в逐囱棒忭舶影ス寝阏件阮磋唑觇晴薏计湘绽燹ù枨砍走谈框簌嚷独骰嚯疫烃元灌抠後皖叹扮鲎瘕ǐ酮い您в鹩簸尴珙溃邡僬练钻岍谱鸬铤漕酏氲增绚臻盗懵怩鸬诽诒炖逻伽麸喂毹仍鞫昙。吻扯ロ鲼绁当荧页羲凳赊庥撄に芳霍芥庹咤珧┼竺柏俣涝ぴ正沭”潆踞鬣瓶蓝圭于阖覃饲遍华晨熹椅勇谚暑抟噫浦饵尥酚ěъ民午恙わ┍臌婴蟥簇蹉陈宣（氇θ蟥苫侠窨方ā猊闷咋镢隈鞫い篓墓拌戗擎鼷廓黼怔鸟犯喜┝悄躐す奥宀ь漤纠蹼螋嗡篦苯伍ざ醭┇皆诱钤倬铜竟驻点轩数馔谏杏哏旄娴跨狍箦螋轶轭篝犷沐ㄟ拖呐踢唣潴潇弋腻扉黹翦湓疱